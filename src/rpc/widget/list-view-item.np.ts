// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufReader, NanoBufWriter, type NanoPackMessage } from "nanopack";

import { Widget } from "./widget.np.js";
import { makeWidget } from "./make-widget.np.js";

class ListViewItem implements NanoPackMessage {
  public static TYPE_ID = 1100735111;

  public readonly typeId: number = 1100735111;

  public readonly headerSize: number = 12;

  constructor(
    public itemTag: number,
    public widget: Widget,
  ) {}

  public static fromBytes(
    bytes: Buffer,
  ): { bytesRead: number; result: ListViewItem } | null {
    const reader = new NanoBufReader(bytes);
    return ListViewItem.fromReader(reader);
  }

  public static fromReader(
    reader: NanoBufReader,
    offset = 0,
  ): { bytesRead: number; result: ListViewItem } | null {
    let ptr = offset + 12;

    const itemTag = reader.readUint32(ptr);
    ptr += 4;

    const maybeWidget = Widget.fromReader(reader, ptr);
    if (!maybeWidget) {
      return null;
    }
    const widget = maybeWidget.result;
    ptr += maybeWidget.bytesRead;

    return {
      bytesRead: ptr - offset,
      result: new ListViewItem(itemTag, widget),
    };
  }

  public writeTo(writer: NanoBufWriter, offset = 0): number {
    let bytesWritten = 12;

    writer.writeTypeId(1100735111, offset);

    writer.appendUint32(this.itemTag);
    writer.writeFieldSize(0, 4, offset);
    bytesWritten += 4;

    const widgetWriteOffset = writer.currentSize;
    writer.reserveHeader(this.widget.headerSize);
    const widgetByteSize = this.widget.writeTo(writer, widgetWriteOffset);
    writer.writeFieldSize(1, widgetByteSize, offset);
    bytesWritten += widgetByteSize;

    return bytesWritten;
  }

  public bytes(): Uint8Array {
    const writer = new NanoBufWriter(12);
    this.writeTo(writer);
    return writer.bytes;
  }
}

export { ListViewItem };
